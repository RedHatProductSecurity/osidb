# Generated by Django 4.2.25 on 2025-11-04 11:03

from django.db import migrations


CREATE_AFFECT_V1_MATERIALIZED_VIEW = """
DROP VIEW IF EXISTS affect_v1;

CREATE MATERIALIZED VIEW affect_v1 AS
-- For all v2 affects, a candidate will be chosen to represent the v1 affect
WITH ranked_affects AS (
    SELECT
        *,
        ROW_NUMBER() OVER (
            PARTITION BY flaw_id, ps_module, ps_component
            ORDER BY
                -- Affected affects take priority
                CASE WHEN affectedness = 'NOTAFFECTED' THEN 2 ELSE 1 END,
                -- Higher impact affects take priority
                CASE impact
                    WHEN 'CRITICAL'  THEN 4
                    WHEN 'IMPORTANT' THEN 3
                    WHEN 'MODERATE'  THEN 2
                    WHEN 'LOW'       THEN 1
                    ELSE 0
                END DESC,
                -- If there's still a tie, take the most recent affect
                created_dt DESC,
                uuid DESC
        ) AS rn
    FROM
        osidb_affect
),
-- Group all trackers from v2 affects into the v1 affect
grouped_trackers AS (
    SELECT
        flaw_id,
        ps_module,
        array_agg(DISTINCT tracker_id) AS all_tracker_ids
    FROM
        osidb_affect
    WHERE
        tracker_id IS NOT NULL
    GROUP BY
        flaw_id, ps_module
),
-- Group all cvss scores from v2 affects into the v1 affect
affect_cvss_ids AS (
    SELECT
        affect_id,
        array_agg(uuid) AS all_cvss_score_ids
    FROM
        osidb_affectcvss
    GROUP BY
        affect_id
)
-- Select the highest-ranked affect (rn = 1) and join with aggregated trackers
SELECT
    ra.uuid,
    ra.flaw_id,
    ra.affectedness,
    ra.resolution,
    ra.ps_module,
    ra.cve_id,
    ra.ps_update_stream,
    ra.ps_component,
    ra.impact,
    ra.purl,
    ra.not_affected_justification,
    ra.resolved_dt,
    ra.meta_attr,
    ra.created_dt,
    ra.updated_dt,
    ra.acl_read,
    ra.acl_write,
    ra.last_validated_dt,
    gt.all_tracker_ids,
    aci.all_cvss_score_ids
FROM
    ranked_affects ra
LEFT JOIN
    grouped_trackers gt ON ra.flaw_id = gt.flaw_id AND ra.ps_module = gt.ps_module
LEFT JOIN
    affect_cvss_ids aci ON ra.uuid = aci.affect_id
WHERE
    ra.rn = 1;

-- Unique index for the concurrent refresh to work
CREATE UNIQUE INDEX affect_v1_uuid_idx ON affect_v1 (uuid);
"""

# Reverse SQL just in case we need to roll back
REVERT_AFFECT_V1_MATERIALIZED_VIEW = """
DROP MATERIALIZED VIEW IF EXISTS affect_v1;

CREATE OR REPLACE VIEW affect_v1 AS
-- For all v2 affects, a candidate will be chosen to represent the v1 affect
WITH ranked_affects AS (
    SELECT
        *,
        ROW_NUMBER() OVER (
            PARTITION BY flaw_id, ps_module, ps_component
            ORDER BY
                -- Affected affects take priority
                CASE WHEN affectedness = 'NOTAFFECTED' THEN 2 ELSE 1 END,
                -- Higher impact affects take priority
                CASE impact
                    WHEN 'CRITICAL'  THEN 4
                    WHEN 'IMPORTANT' THEN 3
                    WHEN 'MODERATE'  THEN 2
                    WHEN 'LOW'       THEN 1
                    ELSE 0
                END DESC,
                -- If there's still a tie, take the most recent affect
                created_dt DESC,
                uuid DESC
        ) AS rn
    FROM
        osidb_affect
),
-- Group all trackers from v2 affects into the v1 affect
grouped_trackers AS (
    SELECT
        flaw_id,
        ps_module,
        array_agg(DISTINCT tracker_id) AS all_tracker_ids
    FROM
        osidb_affect
    WHERE
        tracker_id IS NOT NULL
    GROUP BY
        flaw_id, ps_module
),
-- Group all cvss scores from v2 affects into the v1 affect
affect_cvss_ids AS (
    SELECT
        affect_id,
        array_agg(uuid) AS all_cvss_score_ids
    FROM
        osidb_affectcvss
    GROUP BY
        affect_id
)
-- Select the highest-ranked affect (rn = 1) and join with aggregated trackers
SELECT
    ra.uuid,
    ra.flaw_id,
    ra.affectedness,
    ra.resolution,
    ra.ps_module,
    ra.cve_id,
    ra.ps_update_stream,
    ra.ps_component,
    ra.impact,
    ra.purl,
    ra.not_affected_justification,
    ra.resolved_dt,
    ra.meta_attr,
    ra.created_dt,
    ra.updated_dt,
    ra.acl_read,
    ra.acl_write,
    ra.last_validated_dt,
    gt.all_tracker_ids,
    aci.all_cvss_score_ids
FROM
    ranked_affects ra
LEFT JOIN
    grouped_trackers gt ON ra.flaw_id = gt.flaw_id AND ra.ps_module = gt.ps_module
LEFT JOIN
    affect_cvss_ids aci ON ra.uuid = aci.affect_id
WHERE
    ra.rn = 1;
"""


class Migration(migrations.Migration):

    dependencies = [
        ('osidb', '0209_migrate_incident_states'),
    ]

    operations = [
        migrations.RunSQL(CREATE_AFFECT_V1_MATERIALIZED_VIEW, reverse_sql=REVERT_AFFECT_V1_MATERIALIZED_VIEW),
    ]
