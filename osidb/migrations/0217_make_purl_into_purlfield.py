# Generated by Django 4.2.26 on 2025-12-11 19:02

from django.db import migrations
import osidb.models.fields



CREATE_AFFECT_V1_MATERIALIZED_VIEW = """
DROP MATERIALIZED VIEW IF EXISTS affect_v1;

CREATE MATERIALIZED VIEW affect_v1 AS
-- For all v2 affects, a candidate will be chosen to represent the v1 affect
WITH ranked_affects AS (
    SELECT
        *,
        ROW_NUMBER() OVER (
            PARTITION BY flaw_id, ps_module, ps_component
            ORDER BY
                -- Affects with a PURL that has a subpath (which start with #) take priority
                CASE WHEN purl LIKE '%#%' THEN 1 ELSE 2 END,
                -- Affected affects take priority
                CASE WHEN affectedness = 'NOTAFFECTED' THEN 2 ELSE 1 END,
                -- Higher impact affects take priority
                CASE impact
                    WHEN 'CRITICAL'  THEN 4
                    WHEN 'IMPORTANT' THEN 3
                    WHEN 'MODERATE'  THEN 2
                    WHEN 'LOW'       THEN 1
                    ELSE 0
                END DESC,
                -- If there's still a tie, take the most recent affect
                created_dt DESC,
                uuid DESC
        ) AS rn
    FROM
        osidb_affect
),
-- Group all trackers from v2 affects into the v1 affect
grouped_trackers AS (
    SELECT
        flaw_id,
        ps_module,
        ps_component,
        array_agg(DISTINCT tracker_id) AS all_tracker_ids
    FROM
        osidb_affect
    WHERE
        tracker_id IS NOT NULL
    GROUP BY
        flaw_id, ps_module, ps_component
),
-- Group all cvss scores from v2 affects into the v1 affect
affect_cvss_ids AS (
    SELECT
        affect_id,
        array_agg(uuid) AS all_cvss_score_ids
    FROM
        osidb_affectcvss
    GROUP BY
        affect_id
)
-- Select the highest-ranked affect (rn = 1) and join with aggregated trackers
SELECT
    ra.uuid,
    ra.flaw_id,
    ra.affectedness,
    ra.resolution,
    ra.ps_module,
    ra.cve_id,
    ra.ps_update_stream,
    ra.ps_component,
    ra.impact,
    ra.purl,
    ra.not_affected_justification,
    ra.resolved_dt,
    ra.meta_attr,
    ra.created_dt,
    ra.updated_dt,
    ra.acl_read,
    ra.acl_write,
    ra.last_validated_dt,
    gt.all_tracker_ids,
    aci.all_cvss_score_ids
FROM
    ranked_affects ra
LEFT JOIN
    grouped_trackers gt
        ON ra.flaw_id = gt.flaw_id
        AND ra.ps_module = gt.ps_module
        AND ra.ps_component = gt.ps_component
LEFT JOIN
    affect_cvss_ids aci ON ra.uuid = aci.affect_id
WHERE
    ra.rn = 1;

-- Unique index for the concurrent refresh to work
CREATE UNIQUE INDEX affect_v1_uuid_idx ON affect_v1 (uuid);
"""


class Migration(migrations.Migration):

    dependencies = [
        ('osidb', '0216_subpackage_purls'),
    ]

    operations = [
        migrations.RunSQL(
            sql="DROP MATERIALIZED VIEW IF EXISTS affect_v1;",
            reverse_sql=CREATE_AFFECT_V1_MATERIALIZED_VIEW,
        ),
        migrations.AlterField(
            model_name='affect',
            name='purl',
            field=osidb.models.fields.PURLField(blank=True),
        ),
        migrations.AlterField(
            model_name='affectaudit',
            name='purl',
            field=osidb.models.fields.PURLField(blank=True),
        ),
        migrations.RunSQL(
            sql=CREATE_AFFECT_V1_MATERIALIZED_VIEW,
            reverse_sql="DROP MATERIALIZED VIEW IF EXISTS affect_v1;",
        ),
    ]
