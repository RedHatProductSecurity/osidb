"""
Metasploit exploit data collector
"""
import logging

import requests
from celery.schedules import crontab
from django.utils import timezone

from apps.exploits.helpers import (
    set_exploit_collector_acls,
    store_or_update_exploits,
    update_objects_with_flaws,
)
from apps.exploits.models import Exploit
from collectors.framework.models import collector

logger = logging.getLogger(__name__)

METASPLOIT_URL = "https://raw.githubusercontent.com/rapid7/metasploit-framework/master/db/modules_metadata_base.json"
METASPLOIT_REFERENCE = "https://github.com/rapid7/metasploit-framework/blob/master"


def download():
    response = requests.get(METASPLOIT_URL)
    exploit_data = response.json()
    return exploit_data


def process_data(exploit_data):
    exploit_objects = []

    for exploit in exploit_data:
        references = exploit_data[exploit]["references"]
        date = exploit_data[exploit]["disclosure_date"]
        path = exploit_data[exploit]["path"]
        reference = f"{METASPLOIT_REFERENCE}{path}"
        # There can be multiple CVEs
        cves = [ref for ref in references if ref.startswith("CVE-")]

        for cve in cves:
            e = Exploit(
                cve=cve,
                source=Exploit.ExploitSource.METASPLOIT,
                flaw=None,  # Preliminary set to None, make links later
                date=date,  # Date is available most of the time, but not always
                reference=reference,
                # Based on experience with the source we treat it as
                # "Functional" by default
                maturity_preliminary=Exploit.ExploitMaturity.F,
            )
            exploit_objects.append(e)

    update_objects_with_flaws(exploit_objects)  # Make links to flaws if they exist
    return exploit_objects


def metasploit_collector_main():
    set_exploit_collector_acls()
    data = download()
    objects = process_data(data)
    store_or_update_exploits(objects)


@collector(
    # Execute once a day
    crontab=crontab(minute=5, hour=1),
)
def exploit_metasploit_collector(collector_obj):
    logger.info(f"Collector {collector_obj.name} is running")

    metasploit_collector_main()

    # Save time when the collector ran for the last time
    collector_obj.store(updated_until_dt=timezone.now())

    return f"The {collector_obj.name} finished successfully."
