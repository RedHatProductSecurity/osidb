"""
Exploit-DB exploit data collector
"""
import io
import re
import zipfile
from os import path

import requests
from celery.schedules import crontab
from celery.utils.log import get_task_logger
from django.utils import timezone

from apps.exploits.helpers import (
    set_exploit_collector_acls,
    store_or_update_exploits,
    update_objects_with_flaws,
)
from apps.exploits.models import Exploit
from collectors.framework.models import collector
from osidb.validators import CVE_RE_STR

logger = get_task_logger(__name__)

EXPLOITDB_URL = (
    "https://github.com/offensive-security/exploitdb/archive/refs/heads/master.zip"
)
EXPLOITDB_REFERENCE = "https://github.com/offensive-security/exploitdb/blob/master/"
EXPLOIT_DIR = "exploitdb-master/exploits/"


def find_cves_exploitdb(content):
    """
    Find CVEs in file content of a file stored in Exploit DB.
    Based on possible formats seen when browsing the stored files, there are three possibilities:

    1) CVE-2021-1234
    2) 'CVE', '2009-4265'
    3) CVE ID: 2013-5065

    Currently, it does not seem that there is any useful metadata about applicable CVEs, so parsing
    the file content is the only option available.
    """
    cves = []  # There can be multiple CVEs for each exploit
    if "CVE" in content:
        # CVE-2021-1234
        cves.extend(CVE_RE_STR.findall(content))

        # 'CVE', '2009-4265'
        found = re.findall(r"CVE[', ]+\d{4}-\d+", content)
        fixed = [re.sub(r"CVE[', ]+(\d{4}-\d+)", r"CVE-\1", a) for a in found]
        cves.extend(fixed)

        # CVE ID: 2013-5065
        found = re.findall(r"CVE ID:[ ]+\d{4}-\d+", content)
        fixed = [re.sub(r"CVE ID:[ ]+(\d{4}-\d+)", r"CVE-\1", a) for a in found]
        cves.extend(fixed)
    return cves


def download():
    response = requests.get(EXPLOITDB_URL)
    compressed_file = io.BytesIO(response.content)
    return compressed_file


def process_data(compressed_file):
    exploit_objects = []

    with zipfile.ZipFile(compressed_file) as thezip:
        for filename in thezip.namelist():
            if filename.startswith(EXPLOIT_DIR) and filename != EXPLOIT_DIR:
                thefile = thezip.open(filename)

                # TODO: Is there more reliable way to get CVEs from Exploit-DB then parsing files?
                content = thefile.read().decode("utf-8")
                cves = find_cves_exploitdb(content)

                stripped_path = path.join(*filename.split("/")[1:])
                reference = f"{EXPLOITDB_REFERENCE}{stripped_path}"

                for cve in cves:
                    e = Exploit(
                        cve=cve,
                        source=Exploit.ExploitSource.EXPLOITDB,
                        flaw=None,  # Preliminary set to None, make links later
                        # Date not available due to
                        # https://github.com/offensive-security/exploitdb/issues/206
                        date=None,
                        reference=reference,
                        # Based on experience with the source we treat it as "Proof-of-concept"
                        # by default
                        maturity_preliminary=Exploit.ExploitMaturity.P,
                    )
                    exploit_objects.append(e)

    update_objects_with_flaws(exploit_objects)  # Make links to flaws if they exist
    return exploit_objects


def exploitdb_collector_main():
    set_exploit_collector_acls()
    data = download()
    objects = process_data(data)
    store_or_update_exploits(objects)


@collector(
    # Execute once a day
    crontab=crontab(minute=10, hour=1),
)
def exploit_exploitdb_collector(collector_obj):
    logger.info(f"Collector {collector_obj.name} is running")

    exploitdb_collector_main()

    # Save time when the collector ran for the last time
    collector_obj.store(updated_until_dt=timezone.now())

    return f"The {collector_obj.name} finished successfully."
