import json
import logging

import pytest

from apps.exploits.helpers import store_or_update_exploits
from apps.exploits.models import EPSS, Exploit
from osidb.models import Flaw
from osidb.tests.factories import FlawFactory

logger = logging.getLogger("apps.exploits")
pytestmark = pytest.mark.unit

CISA_TEST_FILE = "apps/exploits/tests/files/CISA/known_exploited_vulnerabilities.json"
METASPLOIT_TEST_FILE = "apps/exploits/tests/files/Metasploit/modules_metadata_base.json"
EXPLOIT_DB_TEST_FILE = "apps/exploits/tests/files/Exploit-db/exploitdb-master.zip"
EPSS_TEST_FILE = "apps/exploits/tests/files/EPSS/epss_scores-test.csv.gz"


class TestParsing(object):
    def test_parsing_cisa(self):
        # Import inside test to avoid using database before
        # enable_db_access_for_all_tests fixture is ready
        from collectors.exploits_cisa.tasks import process_data

        FlawFactory(cve_id="CVE-2222-0001")
        with open(CISA_TEST_FILE) as f:
            objects = process_data(json.load(f))
        store_or_update_exploits(objects)

        # Check parsed exploits
        assert Exploit.objects.count() == 2
        assert Exploit.objects.filter(flaw__isnull=True).count() == 1

        # Check links to Flaws, only one exploit is possible for a CVE
        assert Exploit.objects.get(cve="CVE-2222-0001").flaw == Flaw.objects.get(
            cve_id="CVE-2222-0001"
        )
        assert Exploit.objects.get(cve="CVE-2223-0001").flaw is None

        assert Flaw.objects.get(cve_id="CVE-2222-0001").exploit_set.count() == 1
        assert Flaw.objects.get(
            cve_id="CVE-2222-0001"
        ).exploit_set.first() == Exploit.objects.get(cve="CVE-2222-0001")

    def test_parsing_metasploit(self):
        # Import inside test to avoid using database before
        # enable_db_access_for_all_tests fixture is ready
        from collectors.exploits_metasploit.tasks import process_data

        FlawFactory(cve_id="CVE-2222-0001")
        with open(METASPLOIT_TEST_FILE) as f:
            objects = process_data(json.load(f))
        store_or_update_exploits(objects)

        # Check parsed exploits
        assert Exploit.objects.count() == 3
        assert Exploit.objects.filter(flaw__isnull=True).count() == 1

        # Check links to Flaws, multiple exploits are possible for a CVE
        for exploit in Exploit.objects.filter(cve="CVE-2222-0001"):
            assert exploit.flaw == Flaw.objects.get(cve_id="CVE-2222-0001")
        assert Exploit.objects.get(cve="CVE-2223-0001").flaw is None

        assert Flaw.objects.get(cve_id="CVE-2222-0001").exploit_set.count() == 2
        exploits_for_flaw = list(
            Flaw.objects.get(cve_id="CVE-2222-0001").exploit_set.all()
        )
        exploits_for_cve = list(Exploit.objects.filter(cve="CVE-2222-0001"))
        assert exploits_for_flaw == exploits_for_cve

        # Check that two exploits for the same CVE from the same source have different references
        assert exploits_for_cve[0].reference != exploits_for_cve[1].reference

    def test_parsing_exploit_db(self):
        # Import inside test to avoid using database before
        # enable_db_access_for_all_tests fixture is ready
        from collectors.exploits_exploitdb.tasks import process_data

        FlawFactory(cve_id="CVE-2222-0001")
        objects = process_data(EXPLOIT_DB_TEST_FILE)
        store_or_update_exploits(objects)

        # Check parsed exploits, using different found formats
        assert Exploit.objects.count() == 4
        assert sorted({e.cve for e in Exploit.objects.all()}) == [
            "CVE-2222-0001",
            "CVE-2222-0002",
            "CVE-2222-0003",
        ]

        # Check links to Flaws, multiple exploits are possible for a CVE
        assert Exploit.objects.get(cve="CVE-2222-0001").flaw == Flaw.objects.get(
            cve_id="CVE-2222-0001"
        )
        assert Exploit.objects.get(cve="CVE-2222-0002").flaw is None
        for exploit in Exploit.objects.filter(cve="CVE-2222-0003"):
            assert exploit.flaw is None

        # Check correct references
        assert (
            Exploit.objects.get(cve="CVE-2222-0001").reference
            == Exploit.objects.get(cve="CVE-2222-0002").reference
        )
        assert (
            Exploit.objects.get(cve="CVE-2222-0001").reference
            != Exploit.objects.filter(cve="CVE-2222-0003").first().reference
        )

    def test_parsing_epss(self):
        # Import inside test to avoid using database before
        # enable_db_access_for_all_tests fixture is ready
        from collectors.epss.tasks import process_data, store_objects

        FlawFactory(cve_id="CVE-2222-0001")
        FlawFactory(cve_id="CVE-2222-0002")
        objects = process_data(EPSS_TEST_FILE)
        store_objects(objects)

        assert EPSS.objects.count() == 3

        # Check references
        assert EPSS.objects.get(cve="CVE-2222-0001").flaw == Flaw.objects.get(
            cve_id="CVE-2222-0001"
        )
        assert EPSS.objects.get(cve="CVE-2222-0002").flaw == Flaw.objects.get(
            cve_id="CVE-2222-0002"
        )
        assert EPSS.objects.get(cve="CVE-2022-35131").flaw is None
