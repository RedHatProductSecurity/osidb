from django.conf import settings

from apps.exploits.constants import EXPLOITS_API_VERSION
from apps.exploits.models import Exploit
from osidb.core import set_user_acls
from osidb.models import Flaw
from osidb.models.affect import AffectV1


def update_objects_with_flaws(exploit_objects):
    """
    Take a list of exploit like objects (Exploit or EPSS) which need to be linked with Flaw
    objects. Create a link to Flaw object if it exists for the relevant CVE, otherwise set it to
    None.

    Optimizations:
    * Make a one optimized query to the database instead of N queries (~180k for EPSS).
    * Store just uuid (primary key) instead of whole object in the intermediate map, that saves
      about 500 MB of RAM in case of EPSS and makes it faster
    * Linking is done using 'flaw_id' instead of 'flaw' attribute, which accepts Flaw primary key
      (uuid) instead of Flaw object
    """
    cves = set(exploit.cve for exploit in exploit_objects)
    flaws = Flaw.objects.filter(cve_id__in=cves).values("cve_id", "uuid")
    flaw_map = {flaw["cve_id"]: flaw["uuid"] for flaw in flaws}
    for one_object in exploit_objects:
        one_object.flaw_id = flaw_map.get(one_object.cve, None)


def store_or_update_exploits(exploit_objects):
    """
    Store exploits described by a list of Exploit objects. If object already exists, update
    reference to the Flaw object. This simplifies updating links to flaws by just running
    collection again.

    Date and preliminary maturity should be the same for a specific exploit, but update it
    also if it changes.
    """
    for exploit in exploit_objects:
        Exploit.objects.update_or_create(
            cve=exploit.cve,
            source=exploit.source,
            reference=exploit.reference,
            defaults={
                "flaw": exploit.flaw,
                "date": exploit.date,
                "maturity_preliminary": exploit.maturity_preliminary,
            },
        )


def set_exploit_collector_acls():
    """
    Exploit collectors need access to all flaws, so they can be correctly linked to exploit objects.
    """
    set_user_acls(settings.ALL_GROUPS)


class ExploitResult:
    """
    Class to analyze Exploit and store analysis results for report generation.
    """

    def __init__(self, exploit, version=EXPLOITS_API_VERSION):
        self.cve = exploit.cve
        self.date = exploit.date
        self.flaw = None
        self.affects = None
        self.supported_affects = None
        self.affected_affects = None
        self.unfixed_affects = None
        self.included_affects = None

        self.in_database = False
        self.supported = False
        self.affected = False
        self.unfixed = False
        self.included = False

        self.message = None

        if version == EXPLOITS_API_VERSION:
            self.analyzeV1()
        else:
            self.analyze()

    def _analyze_base(
        self, get_affects_func, unfixed_method_name, terminology, component_key
    ):
        """
        Base analysis function that can be parameterized for different API versions.

        Args:
            get_affects_func: Function to get the affects queryset
            unfixed_method_name: Name of the unfixed method to call on affected_affects
            terminology: String for terminology in messages (e.g., 'update streams' or 'products')
            component_key: Key to use for component identification (e.g., 'ps_update_stream' or 'ps_module')
        """
        self.flaw = Flaw.objects.filter(cve_id=self.cve).first()
        if not self.flaw:
            self.message = "CVE not in Red Hat database"
            return

        self.in_database = True

        self.affects = get_affects_func()
        self.supported_affects = self.affects.supported()
        self.affected_affects = self.supported_affects.affected()
        self.unfixed_affects = getattr(self.affected_affects, unfixed_method_name)()
        self.included_affects = [
            a for a in self.unfixed_affects if not a.should_be_excluded
        ]

        if self.supported_affects:
            self.supported = True
        else:
            if self.affects:
                relevant = self.affects
                items = ", ".join(sorted({getattr(a, component_key) for a in relevant}))
                self.message = f"No supported {terminology} ({items})"
            else:
                self.message = f"No {terminology} in database"
            return

        if self.affected_affects:
            self.affected = True
        else:
            relevant = list(self.supported_affects)
            components = ", ".join(
                sorted(
                    {f"{getattr(a, component_key)}:{a.ps_component}" for a in relevant}
                )
            )
            self.message = f"All components for supported {terminology} are not affected ({components})"
            return

        if self.unfixed_affects:
            self.unfixed = True
        else:
            relevant = list(self.affected_affects)
            components = ", ".join(
                sorted(
                    {f"{getattr(a, component_key)}:{a.ps_component}" for a in relevant}
                )
            )
            self.message = (
                f'All affected components for supported {terminology} are marked as "fix" '
                f"({components})"
            )
            return

        if self.included_affects:
            self.included = True
            self.message = ">> ACTION PENDING <<"
        else:
            relevant = list(self.unfixed_affects)
            components = ", ".join(
                sorted(
                    {f"{getattr(a, component_key)}:{a.ps_component}" for a in relevant}
                )
            )
            self.message = (
                f"All affected unfixed components for supported {terminology} are not on "
                f"inclusion list ({components})"
            )

    def analyze(self):
        """Analyze using the affects V2"""

        self._analyze_base(
            get_affects_func=lambda: self.flaw.affects.all(),
            unfixed_method_name="unfixed",
            terminology="update streams",
            component_key="ps_update_stream",
        )

    def analyzeV1(self):
        """Analyze using the Affects V1"""

        self._analyze_base(
            get_affects_func=lambda: AffectV1.objects.filter(flaw=self.flaw),
            unfixed_method_name="unfixed_v1",
            terminology="products",
            component_key="ps_module",
        )
