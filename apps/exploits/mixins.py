from django.db import models

from apps.exploits.constants import (
    INCLUSION_LIST_PRODUCTS,
    NOT_INCLUSION_LIST_COMPONENTS,
)


class AffectExploitExtensionMixin(models.Model):
    """
    Extends Affect model with a behavior only needed by exploit functionality and reports.
    """

    class Meta:
        abstract = True

    @property
    def tracker_resolution_combined(self):
        """
        Take all tracker resolution values for a specific Affect object, and provide a sorted
        list of distinct values. The main purpose is to provide human-readable information about
        DELEGATED affects, because their resolution is not clear.

        It is used for an exploit query answering the following question:
        What are the flaw-affect combinations with an exploit which are not fixed?

        The important part there is that if Affect is fixed or not is harder to answer for affects
        with resolution DELEGATED. Human review is usually required and providing this information
        is useful.
        """
        tracker_resolutions = set()
        for tracker in self.trackers.all():
            resolution = tracker.resolution
            # Convert weird values to human-readable strings
            if not resolution:
                resolution = "None"
            tracker_resolutions.add(resolution)

        return sorted(tracker_resolutions)

    def _resolution_expanded_base(self, get_tracker_resolution_func):
        """
        Base function for expanding DELEGATED resolutions with tracker information.

        Args:
            get_tracker_resolution_func: Function that returns the tracker resolution string(s)
                                       or None/empty if no resolution is available
        """
        from osidb.models import Affect

        delegated = Affect.AffectResolution.DELEGATED
        if self.resolution == delegated:
            tracker_resolution = get_tracker_resolution_func()
            if tracker_resolution:
                return delegated + "-" + tracker_resolution
            else:
                return delegated + "-None"
        else:
            return self.resolution

    @property
    def resolution_expanded(self):
        """
        For purposes of exploit reports, any DELEGATED resolution needs to be expanded to signify
        state of the tracker in a human-readable form.
        """
        return self._resolution_expanded_base(
            lambda: self.tracker.resolution
            if self.tracker and self.tracker.resolution
            else None
        )

    @property
    def resolution_expanded_v1(self):
        """
        For purposes of exploit reports, any DELEGATED resolution needs to be expanded to signify
        state of the trackers in a human-readable form.
        """
        return self._resolution_expanded_base(
            lambda: "/".join(resolution_combined)
            if (resolution_combined := self.tracker_resolution_combined)
            else None
        )

    @property
    def impact_expanded(self):
        """
        For purposes of exploit reports, impact needs to be expanded, so it signifies either affect
        impact, if it exists, or associated flaw impact otherwise.
        """
        from osidb.models import Impact

        if self.impact == Impact.NOVALUE:
            return self.flaw.impact
        else:
            return self.impact

    @property
    def should_be_excluded(self):
        """
        Any long-term products should have components not on inclusion list removed from any
        exploit related reports.

        Unfortunately, using inclusion list https://access.redhat.com/node/4082531 is not feasible,
        as source RPM / component names are not noted and not trivial to find automatically.
        For that reason static lists of products and components to exclude as we find them was
        created.
        """
        return (
            self.ps_module in INCLUSION_LIST_PRODUCTS
            and self.ps_component in NOT_INCLUSION_LIST_COMPONENTS
        )
