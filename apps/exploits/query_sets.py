from django.db.models import Q

from osidb.query_sets import CustomQuerySetUpdatedDt

from .constants import FIXED_AND_UNFIXABLE_TRACKER_RESOLUTIONS, UNSUPPORTED_PRODUCTS


class AffectQuerySetExploitExtension(CustomQuerySetUpdatedDt):
    """
    Additional Affect queries needed for exploit reports.
    """

    def not_community(self):
        """
        Exclude all community products.
        """
        q = self
        q = q.exclude(ps_module__contains="epel")  # Remove EPEL
        q = q.exclude(ps_module__contains="fedora")  # Remove Fedora
        return q

    def supported(self):
        """
        Exclude all affects which Red Hat does not provide ANY security fixes regardless of the
        flaw impact and affects where we do not particularly care if fix is provided, i.e.
        community products and EOL products.
        """
        q = self
        q = q.not_community()  # Remove community products
        # Remove products which are not supported anymore. This is a temporary workaround until
        # it is possible to check for products which are completely unsupported (no security fixed
        # ever)
        q = q.exclude(ps_module__in=UNSUPPORTED_PRODUCTS)
        return q

    def unfixed_in_delegate(self):
        """
        Exclude all affects which have resolution DELEGATED and the associated tracker is either
        in fixed state, or are not fixable, e.g. duplicate, EOL.
        """
        from osidb.models import Affect

        q = self
        q = q.exclude(
            resolution=Affect.AffectResolution.DELEGATED,
            tracker__resolution__in=FIXED_AND_UNFIXABLE_TRACKER_RESOLUTIONS,
        )
        return q

    def unfixed_in_delegate_v1(self):
        """
        Exclude all affects which have resolution DELEGATED and all associated trackers are either
        in fixed state, or are not fixable, e.g. duplicate, EOL.
        """
        from osidb.models import Affect, Tracker

        unfixed_tracker_uuids = Tracker.objects.filter(
            ~Q(resolution__in=FIXED_AND_UNFIXABLE_TRACKER_RESOLUTIONS)
        ).values_list("uuid", flat=True)

        delegated_fixed_or_unfixable = Q(
            resolution=Affect.AffectResolution.DELEGATED
        ) & ~Q(all_tracker_ids__overlap=unfixed_tracker_uuids)

        return self.exclude(delegated_fixed_or_unfixable)

    def unfixed(self):
        """
        Exclude all affects v2 which either have resolution FIX or have resolution DELEGATED and
        associated tracker allow us to treat it as fixed (see "unfixed_in_delegate" above).
        """
        from osidb.models import Affect

        return self.exclude(
            resolution=Affect.AffectResolution.FIX
        ).unfixed_in_delegate()

    def unfixed_v1(self):
        """
        Exclude all affects v1 which either have resolution FIX or have resolution DELEGATED and
        associated trackers allow us to treat it as fixed (see "unfixed_in_delegate_v1" above).
        """
        from osidb.models import Affect

        return self.exclude(
            resolution=Affect.AffectResolution.FIX
        ).unfixed_in_delegate_v1()

    def affected(self):
        """
        Exclude all affects with affectedness state NOTAFFECTED.
        """
        from osidb.models import Affect

        return self.exclude(affectedness=Affect.AffectAffectedness.NOTAFFECTED)

    def exploit_relevant(self):
        """
        Only affects v2 which are relevant for exploit reviews - i.e. for supported products, for
        affected components, not fixed and potentially fixable.
        """
        return self.supported().affected().unfixed()

    def exploit_relevant_v1(self):
        """
        Only affects v1 which are relevant for exploit reviews - i.e. for supported products, for
        affected components, not fixed and potentially fixable.
        """
        return self.supported().affected().unfixed_v1()
